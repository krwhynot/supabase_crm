/**
 * Opportunity Naming Service
 * Auto-generates opportunity names following the pattern:
 * [Organization] - [Principal] - [Context] - [Month Year]
 */

import type { 
  OpportunityNamePreview, 
  OpportunityContext 
} from '@/types/opportunities'
import type { ApiResponse } from './contactsApi'

/**
 * Name generation options
 */
export interface NameGenerationOptions {
  organization_name: string
  principal_name: string
  context?: OpportunityContext | null
  date?: Date
  custom_context?: string
}

/**
 * Batch name preview request
 */
export interface BatchNamePreviewRequest {
  organization_name: string
  principal_data: Array<{
    id: string
    name: string
  }>
  context?: OpportunityContext | null
  custom_context?: string
  date?: Date
}

/**
 * Name template variables
 */
export interface NameTemplateVariables {
  organization: string
  principal: string
  context: string
  month: string
  year: string
  date: string
}

class OpportunityNamingService {

  /**
   * Generate a single opportunity name
   */
  generateOpportunityName(options: NameGenerationOptions): string {
    const {
      organization_name,
      principal_name,
      context,
      date = new Date(),
      custom_context
    } = options

    // Clean organization and principal names
    const orgName = this.cleanName(organization_name)
    const principalName = this.cleanName(principal_name)
    
    // Get context string
    const contextStr = this.getContextString(context, custom_context)
    
    // Get formatted date
    const dateStr = this.formatDate(date)
    
    // Build name following pattern
    const parts = [orgName, principalName, contextStr, dateStr].filter(Boolean)
    return parts.join(' - ')
  }

  /**
   * Generate name previews for multiple principals
   */
  generateBatchNamePreviews(request: BatchNamePreviewRequest): OpportunityNamePreview[] {
    const {
      organization_name,
      principal_data,
      context,
      custom_context,
      date = new Date()
    } = request

    return principal_data.map(principal => {
      const generatedName = this.generateOpportunityName({
        organization_name,
        principal_name: principal.name,
        context,
        custom_context,
        date
      })

      const nameTemplate = this.generateNameTemplate({
        organization_name,
        principal_name: principal.name,
        context,
        custom_context,
        date
      })

      return {
        principal_id: principal.id,
        principal_name: principal.name,
        generated_name: generatedName,
        name_template: nameTemplate
      }
    })
  }

  /**
   * Generate a name template for auto-generation tracking
   */
  generateNameTemplate(options: NameGenerationOptions): string {
    const {
      context,
      custom_context
    } = options

    const variables: NameTemplateVariables = {
      organization: '{{organization}}',
      principal: '{{principal}}',
      context: this.getContextString(context, custom_context) || '{{context}}',
      month: '{{month}}',
      year: '{{year}}',
      date: '{{date}}'
    }

    // Build template following pattern
    const parts = [
      variables.organization,
      variables.principal,
      variables.context,
      `${variables.month} ${variables.year}`
    ].filter(part => part !== '{{context}}' || context || custom_context)

    return parts.join(' - ')
  }

  /**
   * Validate if a name follows the auto-generated pattern
   */
  isAutoGeneratedName(name: string, nameTemplate: string | null): boolean {
    if (!nameTemplate) return false

    // Convert template to regex pattern
    const regexPattern = nameTemplate
      .replace(/\{\{organization\}\}/g, '([^-]+)')
      .replace(/\{\{principal\}\}/g, '([^-]+)')
      .replace(/\{\{context\}\}/g, '([^-]+)')
      .replace(/\{\{month\}\}/g, '([A-Za-z]+)')
      .replace(/\{\{year\}\}/g, '(\\d{4})')
      .replace(/\{\{date\}\}/g, '([A-Za-z]+ \\d{4})')
      .replace(/\s*-\s*/g, '\\s*-\\s*')

    const regex = new RegExp(`^${regexPattern}$`)
    return regex.test(name.trim())
  }

  /**
   * Extract components from an auto-generated name
   */
  parseAutoGeneratedName(name: string, nameTemplate: string): NameTemplateVariables | null {
    try {
      if (!this.isAutoGeneratedName(name, nameTemplate)) {
        return null
      }

      // This is a simplified parser - in production you might want more robust parsing
      const parts = name.split(' - ').map(part => part.trim())
      
      if (parts.length < 3) return null

      const organization = parts[0] || ''
      const principal = parts[1] || ''
      const context = parts[2] || ''
      const dateStr = parts[3] || ''
      
      // Extract month and year from date string
      const dateParts = dateStr.split(' ')
      const month = dateParts[0] || ''
      const year = dateParts[1] || ''

      return {
        organization,
        principal,
        context,
        month,
        year,
        date: dateStr
      }
    } catch (error) {
      console.error('Error parsing auto-generated name:', error)
      return null
    }
  }

  /**
   * Update name for new context or date
   */
  updateAutoGeneratedName(
    currentName: string,
    nameTemplate: string,
    updates: Partial<NameGenerationOptions>
  ): string {
    const parsed = this.parseAutoGeneratedName(currentName, nameTemplate)
    if (!parsed) {
      // If can't parse, generate new name
      return this.generateOpportunityName(updates as NameGenerationOptions)
    }

    // Apply updates to parsed components
    const updatedOptions: NameGenerationOptions = {
      organization_name: updates.organization_name || parsed.organization,
      principal_name: updates.principal_name || parsed.principal,
      context: updates.context || undefined,
      custom_context: updates.custom_context || parsed.context,
      date: updates.date || new Date()
    }

    return this.generateOpportunityName(updatedOptions)
  }

  /**
   * Check if name is unique (stub for future database integration)
   */
  async isNameUnique(_name: string, _excludeId?: string): Promise<ApiResponse<boolean>> {
    // TODO: Implement actual uniqueness check against database
    // For now, return true as placeholder
    return {
      data: true,
      error: null,
      success: true
    }
  }

  /**
   * Generate unique name by appending counter if needed
   */
  async generateUniqueName(baseOptions: NameGenerationOptions): Promise<ApiResponse<string>> {
    try {
      let baseName = this.generateOpportunityName(baseOptions)
      let finalName = baseName
      let counter = 1

      // Check uniqueness and append counter if needed
      while (!(await this.isNameUnique(finalName)).data) {
        finalName = `${baseName} (${counter})`
        counter++
        
        // Prevent infinite loop
        if (counter > 100) {
          throw new Error('Could not generate unique name after 100 attempts')
        }
      }

      return {
        data: finalName,
        error: null,
        success: true
      }
    } catch (error) {
      console.error('Error generating unique name:', error)
      return {
        data: null,
        error: 'Failed to generate unique opportunity name',
        success: false
      }
    }
  }

  /**
   * Clean name by removing extra spaces and special characters
   */
  private cleanName(name: string): string {
    return name
      .trim()
      .replace(/\s+/g, ' ')  // Replace multiple spaces with single space
      .replace(/[^\w\s&.-]/g, '')  // Remove special chars except &, ., -
      .trim()
  }

  /**
   * Get context string from enum or custom value
   */
  private getContextString(
    context?: OpportunityContext | null, 
    customContext?: string
  ): string {
    if (customContext?.trim()) {
      return this.cleanName(customContext)
    }
    
    if (context) {
      return context
    }
    
    return ''  // No context
  }

  /**
   * Format date as "Month Year" (e.g., "January 2024")
   */
  private formatDate(date: Date): string {
    const monthNames = [
      'January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'
    ]
    
    const month = monthNames[date.getMonth()]
    const year = date.getFullYear()
    
    return `${month} ${year}`
  }

}

// Export singleton instance
export const opportunityNaming = new OpportunityNamingService()

// Export class for testing
export { OpportunityNamingService }

// Export utility functions for direct use
export const generateOpportunityName = (options: NameGenerationOptions): string => {
  return opportunityNaming.generateOpportunityName(options)
}

export const generateBatchNamePreviews = (request: BatchNamePreviewRequest): OpportunityNamePreview[] => {
  return opportunityNaming.generateBatchNamePreviews(request)
}