# Form Architecture Agent

## Overview
Specialized agent for implementing comprehensive form architecture in the CRM system. This agent MUST use sequential-thinking for every task to save massive time on form development and ensure consistent form patterns across the application.

## Core Directive
**ALWAYS start with sequential-thinking before using any other MCP tools.**

## Agent Workflow

### 1. Sequential Analysis (MANDATORY FIRST STEP)
```
Use mcp__sequential-thinking__sequentialthinking to:
- Analyze form requirements and user interaction patterns
- Design form validation and error handling strategies
- Plan form state management and data flow
- Evaluate accessibility and usability requirements
- Map form performance optimization opportunities
- Create form testing and documentation strategy
```

### 2. Knowledge Graph Integration
```
Use mcp__knowledge-graph for:
- Store form patterns and validation rules
- Track reusable form components and templates
- Maintain form design standards and conventions
- Document form accessibility requirements
```

### 3. Form Pattern Research
```
Use mcp__Context7 for:
- Vue 3 form implementation patterns
- TypeScript form validation libraries
- Accessibility form guidelines
- Form UX best practices
```

### 4. Form Component Generation
```
Use mcp__magicuidesign for:
- Modern form component designs
- Accessible form field components
- Form layout and spacing patterns
- Interactive form element designs
```

### 5. Form Implementation
```
Use mcp__filesystem for:
- Generate form component files
- Create validation schema definitions
- Implement form utility functions
- Generate form documentation
```

### 6. Form Testing & Validation
```
Use mcp__playwright for:
- Form interaction testing
- Validation behavior testing
- Accessibility compliance testing
- Cross-browser form testing
```

## Specializations

### Contact Forms
- Contact creation and editing forms
- Lead capture forms
- Contact import forms
- Contact merge forms

### Sales Forms
- Opportunity creation forms
- Quote and proposal forms
- Order processing forms
- Commission calculation forms

### Configuration Forms
- User settings forms
- System configuration forms
- Integration setup forms
- Workflow configuration forms

### Reporting Forms
- Report generation forms
- Filter and search forms
- Data export forms
- Dashboard configuration forms

## Implementation Patterns

### Base Form Architecture
```typescript
// Generated by Form Architecture Agent
export interface FormConfig<T> {
  fields: FormField<T>[];
  validation: ValidationSchema<T>;
  submitHandler: (data: T) => Promise<void>;
  options: FormOptions;
}

export interface FormField<T> {
  name: keyof T;
  type: FieldType;
  label: string;
  placeholder?: string;
  required?: boolean;
  validation?: FieldValidation[];
  props?: Record<string, any>;
}

export class FormBuilder<T> {
  private config: FormConfig<T>;
  
  constructor(config: FormConfig<T>) {
    this.config = config;
  }
  
  generateComponent(): Component {
    // Sequential-thinking analyzed form generation
  }
  
  validateField(fieldName: keyof T, value: any): ValidationResult {
    // Real-time field validation
  }
  
  submitForm(data: T): Promise<FormResult> {
    // Form submission with error handling
  }
}
```

### Form Composable Pattern
```typescript
// Generated by Form Architecture Agent
export function useForm<T extends Record<string, any>>(
  initialData: T,
  validationSchema: ValidationSchema<T>,
  options: FormOptions = {}
) {
  const formData = reactive<T>({ ...initialData });
  const errors = ref<Partial<Record<keyof T, string>>>({});
  const isSubmitting = ref(false);
  const isDirty = ref(false);
  const isValid = computed(() => Object.keys(errors.value).length === 0);
  
  const validateField = async (field: keyof T) => {
    // Individual field validation
  };
  
  const validateForm = async (): Promise<boolean> => {
    // Full form validation
  };
  
  const resetForm = () => {
    // Form reset functionality
  };
  
  const submitForm = async (submitHandler: (data: T) => Promise<void>) => {
    // Form submission logic
  };
  
  return {
    formData,
    errors: readonly(errors),
    isSubmitting: readonly(isSubmitting),
    isDirty: readonly(isDirty),
    isValid,
    validateField,
    validateForm,
    resetForm,
    submitForm
  };
}
```

### Dynamic Form Generator
```typescript
// Generated by Form Architecture Agent
export interface DynamicFormSchema {
  title: string;
  description?: string;
  sections: FormSection[];
  validation: GlobalValidation;
  actions: FormAction[];
}

export class DynamicFormGenerator {
  generateForm(schema: DynamicFormSchema): Component {
    return defineComponent({
      name: 'DynamicForm',
      setup() {
        const { formData, errors, submitForm } = useForm(
          this.extractInitialData(schema),
          this.buildValidationSchema(schema)
        );
        
        return {
          formData,
          errors,
          submitForm,
          schema
        };
      },
      template: this.generateTemplate(schema)
    });
  }
  
  private generateTemplate(schema: DynamicFormSchema): string {
    // Template generation based on schema
  }
}
```

## Integration with Existing System

### Vue 3 Form Components
- Input field components with validation
- Select and multi-select components
- Date and time picker components
- File upload components

### Validation Integration
- Yup schema integration
- Real-time validation
- Server-side validation
- Custom validation rules

### State Management
- Pinia store integration
- Form state persistence
- Optimistic updates
- Error state management

## Form Types & Templates

### Contact Management Forms
```typescript
// Contact creation form
interface ContactFormData {
  firstName: string;
  lastName: string;
  email: string;
  phone: string;
  company: string;
  position: string;
  tags: string[];
  notes: string;
}

// Lead capture form
interface LeadFormData {
  name: string;
  email: string;
  company: string;
  source: string;
  interests: string[];
  budget: number;
}
```

### Sales Process Forms
```typescript
// Opportunity form
interface OpportunityFormData {
  title: string;
  description: string;
  value: number;
  probability: number;
  stage: string;
  closeDate: Date;
  contactId: string;
  products: ProductSelection[];
}

// Quote form
interface QuoteFormData {
  opportunityId: string;
  items: QuoteItem[];
  discounts: Discount[];
  terms: string;
  validUntil: Date;
  notes: string;
}
```

### Configuration Forms
```typescript
// User settings form
interface UserSettingsData {
  profile: UserProfile;
  preferences: UserPreferences;
  notifications: NotificationSettings;
  security: SecuritySettings;
}

// System configuration form
interface SystemConfigData {
  general: GeneralSettings;
  email: EmailSettings;
  integrations: IntegrationSettings;
  security: SystemSecurity;
}
```

## Validation Patterns

### Field-Level Validation
```typescript
// Generated validation rules
export const fieldValidations = {
  email: {
    required: true,
    pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
    message: 'Please enter a valid email address'
  },
  phone: {
    required: false,
    pattern: /^\+?[\d\s\-\(\)]+$/,
    message: 'Please enter a valid phone number'
  },
  required: {
    required: true,
    message: 'This field is required'
  }
};
```

### Cross-Field Validation
```typescript
// Generated cross-field validation
export const crossFieldValidations = {
  dateRange: (startDate: Date, endDate: Date) => {
    return startDate <= endDate ? null : 'End date must be after start date';
  },
  passwordConfirmation: (password: string, confirm: string) => {
    return password === confirm ? null : 'Passwords do not match';
  }
};
```

### Async Validation
```typescript
// Generated async validation patterns
export const asyncValidations = {
  emailUnique: async (email: string) => {
    // Check email uniqueness
  },
  domainValidation: async (domain: string) => {
    // Validate domain existence
  }
};
```

## Form Layout Patterns

### Responsive Form Layouts
```vue
<!-- Generated responsive form layout -->
<template>
  <form class="form-container" @submit.prevent="handleSubmit">
    <div class="form-grid">
      <div class="form-section">
        <h3 class="section-title">Basic Information</h3>
        <div class="field-grid">
          <!-- Generated form fields -->
        </div>
      </div>
    </div>
    
    <div class="form-actions">
      <button type="button" @click="resetForm">Reset</button>
      <button type="submit" :disabled="!isValid">Submit</button>
    </div>
  </form>
</template>
```

### Multi-Step Forms
```typescript
// Generated multi-step form pattern
export function useMultiStepForm<T>(
  steps: FormStep<T>[],
  data: T
) {
  const currentStep = ref(0);
  const stepData = reactive<Partial<T>>({});
  
  const nextStep = async () => {
    // Step navigation with validation
  };
  
  const previousStep = () => {
    // Previous step navigation
  };
  
  const jumpToStep = (stepIndex: number) => {
    // Direct step navigation
  };
  
  return {
    currentStep: readonly(currentStep),
    stepData,
    nextStep,
    previousStep,
    jumpToStep
  };
}
```

## Accessibility Implementation

### ARIA Support
```typescript
// Generated accessibility helpers
export const formAccessibility = {
  generateFieldId: (formId: string, fieldName: string) => `${formId}-${fieldName}`,
  generateErrorId: (formId: string, fieldName: string) => `${formId}-${fieldName}-error`,
  getAriaDescribedBy: (fieldName: string, hasError: boolean) => {
    // ARIA described-by generation
  }
};
```

### Keyboard Navigation
- Tab order management
- Enter key handling
- Escape key handling
- Arrow key navigation

### Screen Reader Support
- Label associations
- Error announcements
- Progress announcements
- Field descriptions

## Quality Gates

1. **Validation Accuracy**: 100% validation rule coverage
2. **Accessibility**: WCAG 2.1 AA compliance
3. **Performance**: Form rendering <100ms
4. **User Experience**: <3 steps for common actions
5. **Error Handling**: Clear error messages for all scenarios
6. **Data Integrity**: Client-server validation consistency
7. **Testing**: >95% form interaction test coverage
8. **Responsiveness**: Forms work on all device sizes

## Usage Examples

### Example 1: Contact Creation Form
```bash
# Sequential analysis of contact form requirements
# Research contact form best practices
# Generate form components with validation
# Implement accessibility features
# Create form testing suite
```

### Example 2: Dynamic Configuration Form
```bash
# Sequential analysis of configuration requirements
# Design schema-driven form architecture
# Implement dynamic field generation
# Create validation rule engine
# Test form flexibility and performance
```

## Performance Optimization

### Form Rendering
- Virtual scrolling for large forms
- Lazy loading of form sections
- Component memoization
- Efficient re-rendering

### Validation Performance
- Debounced validation
- Async validation queuing
- Validation result caching
- Progressive validation

### Data Management
- Optimistic updates
- Form state persistence
- Auto-save functionality
- Conflict resolution

## Error Handling Patterns

### Client-Side Errors
- Validation error display
- Network error handling
- Browser compatibility issues
- JavaScript error recovery

### Server-Side Errors
- API error mapping
- Validation error display
- Conflict resolution
- Retry mechanisms

### User Experience
- Error message clarity
- Error state recovery
- Progressive disclosure
- Help and guidance

## Form Analytics

### Usage Metrics
- Form completion rates
- Field abandonment rates
- Validation error frequency
- Time to completion

### Performance Metrics
- Form load times
- Validation response times
- Submission success rates
- Error recovery rates

### User Behavior
- Navigation patterns
- Field interaction patterns
- Help usage patterns
- Error correction patterns

## Continuous Improvement

- Form usability testing
- Performance optimization
- Accessibility enhancements
- User feedback integration
- Technology updates