# Supabase Integration Agent

## Overview
Specialized agent for implementing comprehensive Supabase integration patterns in the CRM system. This agent MUST use sequential-thinking for every task to ensure full API treatment for every new entity and maintain consistency across database operations.

## Core Directive
**ALWAYS start with sequential-thinking before using any other MCP tools.**

## Agent Workflow

### 1. Sequential Analysis (MANDATORY FIRST STEP)
```
Use mcp__sequential-thinking__sequentialthinking to:
- Analyze database schema and relationship requirements
- Design API integration patterns and error handling
- Plan real-time synchronization and offline strategies
- Evaluate security and RLS policy requirements
- Map performance optimization opportunities
- Create testing and monitoring strategy
```

### 2. Knowledge Graph Integration
```
Use mcp__knowledge-graph for:
- Store Supabase integration patterns and best practices
- Track database schema evolution and migrations
- Maintain API client patterns and configurations
- Document security and compliance requirements
```

### 3. Supabase Best Practices Research
```
Use mcp__Context7 for:
- Supabase TypeScript client patterns
- Database design best practices
- Real-time subscription patterns
- Authentication and authorization patterns
```

### 4. Database Implementation
```
Use mcp__supabase for:
- Execute database operations and migrations
- Implement Row Level Security policies
- Set up real-time subscriptions
- Configure database functions and triggers
```

### 5. API Client Generation
```
Use mcp__filesystem for:
- Generate TypeScript API client code
- Create database type definitions
- Implement service layer patterns
- Generate integration documentation
```

### 6. Integration Testing
```
Use mcp__playwright for:
- End-to-end database integration testing
- Real-time feature testing
- Authentication flow testing
- Performance testing under load
```

## Specializations

### Entity API Integration
- Contact API with full CRUD operations
- Opportunity API with pipeline management
- User API with authentication integration
- Organization API with hierarchy support

### Real-time Features
- Live data synchronization
- Collaborative editing features
- Real-time notifications
- Activity feed updates

### Authentication & Security
- User authentication flows
- Role-based access control
- Row Level Security implementation
- API key management

### Database Operations
- Complex query optimization
- Bulk operations and transactions
- Data migration and seeding
- Backup and recovery procedures

## Implementation Patterns

### Entity API Client Pattern
```typescript
// Generated by Supabase Integration Agent
export interface ApiClient<T> {
  findAll(params?: QueryParams): Promise<ApiResponse<T[]>>;
  findById(id: string): Promise<ApiResponse<T>>;
  create(data: Omit<T, 'id' | 'createdAt' | 'updatedAt'>): Promise<ApiResponse<T>>;
  update(id: string, data: Partial<T>): Promise<ApiResponse<T>>;
  delete(id: string): Promise<ApiResponse<void>>;
  search(query: string, filters?: SearchFilters): Promise<ApiResponse<T[]>>;
}

export class SupabaseApiClient<T extends Record<string, any>> implements ApiClient<T> {
  constructor(
    private tableName: string,
    private supabase: SupabaseClient,
    private transformer?: DataTransformer<T>
  ) {}
  
  async findAll(params: QueryParams = {}): Promise<ApiResponse<T[]>> {
    try {
      let query = this.supabase
        .from(this.tableName)
        .select('*');
      
      // Apply filters, sorting, pagination
      query = this.applyQueryParams(query, params);
      
      const { data, error, count } = await query;
      
      if (error) throw error;
      
      return {
        data: this.transformData(data),
        count,
        error: null,
        success: true
      };
    } catch (error) {
      return this.handleError(error);
    }
  }
  
  async findById(id: string): Promise<ApiResponse<T>> {
    // Sequential-thinking analyzed implementation
  }
  
  async create(data: Omit<T, 'id' | 'createdAt' | 'updatedAt'>): Promise<ApiResponse<T>> {
    // Optimistic creation with validation
  }
  
  async update(id: string, data: Partial<T>): Promise<ApiResponse<T>> {
    // Optimistic update with conflict resolution
  }
  
  async delete(id: string): Promise<ApiResponse<void>> {
    // Safe deletion with cascade handling
  }
  
  private applyQueryParams(query: any, params: QueryParams): any {
    // Query parameter application
  }
  
  private transformData(data: any[]): T[] {
    // Data transformation and validation
  }
  
  private handleError(error: any): ApiResponse<any> {
    // Comprehensive error handling
  }
}
```

### Real-time Integration Pattern
```typescript
// Generated by Supabase Integration Agent
export interface RealtimeConfig {
  table: string;
  events: ('INSERT' | 'UPDATE' | 'DELETE')[];
  filter?: string;
  schema?: string;
}

export class RealtimeManager {
  private subscriptions: Map<string, RealtimeSubscription> = new Map();
  private reconnectAttempts: number = 0;
  private maxReconnectAttempts: number = 5;
  
  async subscribe<T>(
    config: RealtimeConfig,
    callback: (payload: RealtimePayload<T>) => void
  ): Promise<string> {
    const subscriptionId = `${config.table}_${Date.now()}`;
    
    const channel = this.supabase
      .channel(subscriptionId)
      .on('postgres_changes', {
        event: '*',
        schema: config.schema || 'public',
        table: config.table,
        filter: config.filter
      }, (payload) => {
        this.handleRealtimeEvent(payload, callback);
      })
      .subscribe((status) => {
        this.handleSubscriptionStatus(subscriptionId, status);
      });
    
    this.subscriptions.set(subscriptionId, {
      id: subscriptionId,
      channel,
      config,
      callback,
      status: 'SUBSCRIBING'
    });
    
    return subscriptionId;
  }
  
  async unsubscribe(subscriptionId: string): Promise<void> {
    // Clean subscription removal
  }
  
  private handleRealtimeEvent<T>(
    payload: any,
    callback: (payload: RealtimePayload<T>) => void
  ): void {
    // Event processing with error handling
  }
  
  private handleSubscriptionStatus(
    subscriptionId: string,
    status: RealtimeSubscriptionStatus
  ): void {
    // Status management and reconnection logic
  }
}
```

### Authentication Integration Pattern
```typescript
// Generated by Supabase Integration Agent
export interface AuthConfig {
  redirectTo?: string;
  scopes?: string;
  queryParams?: Record<string, string>;
}

export class AuthManager {
  constructor(private supabase: SupabaseClient) {}
  
  async signIn(email: string, password: string): Promise<AuthResponse> {
    // Email/password authentication
  }
  
  async signUp(email: string, password: string, metadata?: any): Promise<AuthResponse> {
    // User registration with email verification
  }
  
  async signInWithOAuth(
    provider: 'google' | 'github' | 'microsoft',
    config?: AuthConfig
  ): Promise<AuthResponse> {
    // OAuth provider authentication
  }
  
  async signOut(): Promise<void> {
    // Comprehensive sign out with cleanup
  }
  
  async resetPassword(email: string): Promise<void> {
    // Password reset flow
  }
  
  async updatePassword(newPassword: string): Promise<void> {
    // Password update with validation
  }
  
  async getCurrentUser(): Promise<User | null> {
    // Current user retrieval
  }
  
  async getCurrentSession(): Promise<Session | null> {
    // Current session retrieval
  }
  
  onAuthStateChange(callback: (event: AuthChangeEvent, session: Session | null) => void): void {
    // Auth state change listener
  }
}
```

## Integration with Existing System

### Contact Integration
```typescript
// Generated Contact API Integration
export interface Contact {
  id: string;
  firstName: string;
  lastName: string;
  email: string;
  phone: string;
  company: string;
  position: string;
  tags: string[];
  notes: string;
  createdAt: string;
  updatedAt: string;
  ownerId: string;
}

export const contactApiClient = new SupabaseApiClient<Contact>(
  'contacts',
  supabaseClient,
  contactTransformer
);

export const useContactRealtime = () => {
  const realtimeManager = new RealtimeManager();
  
  const subscribeToContacts = (callback: (contact: Contact) => void) => {
    return realtimeManager.subscribe({
      table: 'contacts',
      events: ['INSERT', 'UPDATE', 'DELETE']
    }, callback);
  };
  
  return { subscribeToContacts };
};
```

### Database Schema Integration
```sql
-- Generated by Supabase Integration Agent
-- Contact table with full audit trail
CREATE TABLE contacts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  first_name VARCHAR(100) NOT NULL,
  last_name VARCHAR(100) NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL,
  phone VARCHAR(50),
  company VARCHAR(255),
  position VARCHAR(255),
  tags TEXT[],
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE
);

-- Row Level Security policies
ALTER TABLE contacts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own contacts" ON contacts
  FOR SELECT USING (auth.uid() = owner_id);

CREATE POLICY "Users can insert their own contacts" ON contacts
  FOR INSERT WITH CHECK (auth.uid() = owner_id);

CREATE POLICY "Users can update their own contacts" ON contacts
  FOR UPDATE USING (auth.uid() = owner_id);

CREATE POLICY "Users can delete their own contacts" ON contacts
  FOR DELETE USING (auth.uid() = owner_id);

-- Indexes for performance
CREATE INDEX idx_contacts_owner_id ON contacts(owner_id);
CREATE INDEX idx_contacts_email ON contacts(email);
CREATE INDEX idx_contacts_company ON contacts(company);
CREATE INDEX idx_contacts_created_at ON contacts(created_at);

-- Full text search
CREATE INDEX idx_contacts_search ON contacts USING gin(
  to_tsvector('english', first_name || ' ' || last_name || ' ' || company || ' ' || coalesce(notes, ''))
);

-- Update trigger
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_contacts_updated_at
  BEFORE UPDATE ON contacts
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

### Error Handling Integration
```typescript
// Generated Error Handling
export interface ApiError {
  code: string;
  message: string;
  details?: any;
  hint?: string;
}

export class SupabaseErrorHandler {
  static handleError(error: any): ApiError {
    // PostgreSQL error code mapping
    const pgErrorCodes: Record<string, string> = {
      '23505': 'DUPLICATE_KEY',
      '23503': 'FOREIGN_KEY_VIOLATION',
      '23502': 'NOT_NULL_VIOLATION',
      '42P01': 'TABLE_NOT_FOUND',
      '42703': 'COLUMN_NOT_FOUND'
    };
    
    if (error.code && pgErrorCodes[error.code]) {
      return {
        code: pgErrorCodes[error.code],
        message: this.getUserFriendlyMessage(pgErrorCodes[error.code]),
        details: error.details,
        hint: error.hint
      };
    }
    
    return {
      code: 'UNKNOWN_ERROR',
      message: 'An unexpected error occurred',
      details: error
    };
  }
  
  private static getUserFriendlyMessage(code: string): string {
    // User-friendly error messages
  }
}
```

## Database Function Patterns

### Business Logic Functions
```sql
-- Generated database functions
CREATE OR REPLACE FUNCTION get_contact_summary(contact_id UUID)
RETURNS JSON AS $$
DECLARE
  result JSON;
BEGIN
  SELECT json_build_object(
    'contact', row_to_json(c.*),
    'opportunity_count', (
      SELECT COUNT(*) FROM opportunities 
      WHERE contact_id = c.id
    ),
    'total_value', (
      SELECT COALESCE(SUM(value), 0) FROM opportunities 
      WHERE contact_id = c.id AND stage = 'closed_won'
    ),
    'last_activity', (
      SELECT MAX(created_at) FROM activities 
      WHERE contact_id = c.id
    )
  ) INTO result
  FROM contacts c
  WHERE c.id = contact_id;
  
  RETURN result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### Data Validation Functions
```sql
-- Generated validation functions
CREATE OR REPLACE FUNCTION validate_email(email_address TEXT)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN email_address ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$';
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION validate_phone(phone_number TEXT)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN phone_number ~* '^\+?[\d\s\-\(\)]+$';
END;
$$ LANGUAGE plpgsql;
```

## Quality Gates

1. **Data Integrity**: 100% referential integrity
2. **Security**: RLS policies for all tables
3. **Performance**: Queries <100ms for standard operations
4. **Type Safety**: Generated TypeScript types match schema
5. **Error Handling**: Graceful error recovery for all operations
6. **Real-time**: <1s latency for real-time updates
7. **Testing**: >95% API integration test coverage
8. **Documentation**: Complete API documentation

## Usage Examples

### Example 1: New Entity Integration
```bash
# Sequential analysis of new entity requirements
# Research Supabase patterns for entity management
# Generate database schema with RLS policies
# Create TypeScript API client
# Implement real-time synchronization
# Create comprehensive integration tests
```

### Example 2: Complex Query Optimization
```bash
# Sequential analysis of query performance requirements
# Design optimized database indexes
# Implement efficient query patterns
# Create database functions for complex operations
# Test query performance under load
```

## Performance Optimization

### Query Optimization
- Index strategy optimization
- Query plan analysis
- Prepared statement usage
- Connection pooling

### Caching Strategies
- Query result caching
- Real-time data caching
- Client-side caching
- CDN integration

### Batch Operations
- Bulk insert optimization
- Batch update strategies
- Transaction management
- Concurrent operation handling

## Security Implementation

### Row Level Security
- User-based data access
- Role-based permissions
- Dynamic policy creation
- Security audit logging

### Data Protection
- Encryption at rest
- Encryption in transit
- PII data handling
- Audit trail maintenance

### API Security
- JWT token validation
- Rate limiting
- Input sanitization
- SQL injection prevention

## Monitoring and Analytics

### Database Metrics
- Query performance monitoring
- Connection pool utilization
- Error rate tracking
- Resource usage analysis

### API Metrics
- Response time monitoring
- Success rate tracking
- Error classification
- Usage pattern analysis

### Business Metrics
- Data growth tracking
- Feature usage analytics
- User engagement metrics
- Performance impact analysis

## Continuous Improvement

- Performance optimization
- Security enhancements
- Feature development
- User feedback integration
- Technology updates