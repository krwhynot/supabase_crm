/**
 * Service Worker for CRM Mobile PWA
 * Provides offline functionality, background sync, and caching
 */

const CACHE_NAME = 'crm-mobile-v1'
const OFFLINE_CACHE = 'crm-offline-v1'
const BACKGROUND_SYNC_TAG = 'interaction-sync'

// Core app resources to cache for offline use
const CORE_RESOURCES = [
  '/',
  '/index.html',
  '/manifest.json',
  '/src/main.ts',
  '/src/App.vue',
  // Add critical CSS and JS files that would be generated by Vite
]

// API endpoints that support offline caching (reserved for future use)
// const CACHEABLE_APIS = [
//   '/api/organizations',
//   '/api/opportunities', 
//   '/api/principals',
//   '/api/products',
//   '/api/interactions'
// ]

// Offline interaction queue for background sync (using IndexedDB instead)
// let offlineInteractions = []

/**
 * Service Worker Installation
 * Cache core resources for offline functionality
 */
self.addEventListener('install', event => {
  console.log('Service Worker: Installing...')
  
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => {
        console.log('Service Worker: Caching core resources')
        return cache.addAll(CORE_RESOURCES)
      })
      .then(() => {
        console.log('Service Worker: Installation complete')
        return self.skipWaiting()
      })
      .catch(error => {
        console.error('Service Worker: Installation failed', error)
      })
  )
})

/**
 * Service Worker Activation
 * Clean up old caches and take control
 */
self.addEventListener('activate', event => {
  console.log('Service Worker: Activating...')
  
  event.waitUntil(
    caches.keys()
      .then(cacheNames => {
        return Promise.all(
          cacheNames.map(cacheName => {
            if (cacheName !== CACHE_NAME && cacheName !== OFFLINE_CACHE) {
              console.log('Service Worker: Deleting old cache', cacheName)
              return caches.delete(cacheName)
            }
          })
        )
      })
      .then(() => {
        console.log('Service Worker: Activation complete')
        return self.clients.claim()
      })
  )
})

/**
 * Fetch Event Handler
 * Implements offline-first strategy with cache fallback
 */
self.addEventListener('fetch', event => {
  const { request } = event
  const url = new URL(request.url)
  
  // Handle API requests with cache-first strategy for GET requests
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(handleApiRequest(request))
    return
  }
  
  // Handle navigation requests (pages)
  if (request.mode === 'navigate') {
    event.respondWith(handleNavigationRequest(request))
    return
  }
  
  // Handle static assets with cache-first strategy
  event.respondWith(handleStaticAssets(request))
})

/**
 * Handle API requests with intelligent caching
 */
async function handleApiRequest(request) {
  const url = new URL(request.url)
  
  try {
    // For POST/PUT/DELETE requests while offline, queue for background sync
    if (!navigator.onLine && ['POST', 'PUT', 'DELETE', 'PATCH'].includes(request.method)) {
      if (url.pathname.includes('/interactions')) {
        await queueInteractionForSync(request)
        return new Response(
          JSON.stringify({ 
            success: true, 
            message: 'Interaction queued for sync when online',
            queued: true
          }),
          { 
            status: 202,
            headers: { 'Content-Type': 'application/json' }
          }
        )
      }
    }
    
    // Try network first for real-time data
    const networkResponse = await fetch(request.clone())
    
    // Cache successful GET responses
    if (request.method === 'GET' && networkResponse.ok) {
      const cache = await caches.open(OFFLINE_CACHE)
      cache.put(request, networkResponse.clone())
    }
    
    return networkResponse
    
  } catch (error) {
    console.log('Network request failed, trying cache:', error)
    
    // Return cached version for GET requests
    if (request.method === 'GET') {
      const cachedResponse = await caches.match(request)
      if (cachedResponse) {
        return cachedResponse
      }
    }
    
    // Return offline indicator for failed requests
    return new Response(
      JSON.stringify({ 
        error: 'Offline',
        message: 'This request requires an internet connection'
      }),
      { 
        status: 503,
        headers: { 'Content-Type': 'application/json' }
      }
    )
  }
}

/**
 * Handle navigation requests with offline support
 */
async function handleNavigationRequest(request) {
  try {
    // Try network first
    const networkResponse = await fetch(request)
    return networkResponse
    
  } catch (error) {
    // Fallback to cached index.html for SPA routing
    const cache = await caches.open(CACHE_NAME)
    const cachedResponse = await cache.match('/index.html')
    
    if (cachedResponse) {
      return cachedResponse
    }
    
    // Last resort: offline page
    return new Response(
      `<!DOCTYPE html>
      <html>
        <head>
          <title>CRM Mobile - Offline</title>
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <style>
            body { font-family: system-ui, sans-serif; text-align: center; padding: 2rem; }
            .offline-icon { font-size: 3rem; margin-bottom: 1rem; }
          </style>
        </head>
        <body>
          <div class="offline-icon">ðŸ“±</div>
          <h1>You're Offline</h1>
          <p>Check your internet connection and try again.</p>
          <button onclick="window.location.reload()">Retry</button>
        </body>
      </html>`,
      {
        status: 200,
        headers: { 'Content-Type': 'text/html' }
      }
    )
  }
}

/**
 * Handle static assets with cache-first strategy
 */
async function handleStaticAssets(request) {
  try {
    // Try cache first for static assets
    const cachedResponse = await caches.match(request)
    if (cachedResponse) {
      return cachedResponse
    }
    
    // Fetch from network and cache
    const networkResponse = await fetch(request)
    if (networkResponse.ok) {
      const cache = await caches.open(CACHE_NAME)
      cache.put(request, networkResponse.clone())
    }
    
    return networkResponse
    
  } catch (error) {
    // Return cached version if available
    const cachedResponse = await caches.match(request)
    if (cachedResponse) {
      return cachedResponse
    }
    
    throw error
  }
}

/**
 * Queue interaction for background sync
 */
async function queueInteractionForSync(request) {
  const interactionData = await request.json()
  
  const queueItem = {
    id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
    method: request.method,
    url: request.url,
    data: interactionData,
    timestamp: Date.now(),
    headers: Object.fromEntries(request.headers.entries())
  }
  
  // Store in IndexedDB for persistence
  await storeOfflineInteraction(queueItem)
  
  // Register background sync
  if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
    await self.registration.sync.register(BACKGROUND_SYNC_TAG)
  }
}

/**
 * Background Sync Event Handler
 * Sync queued interactions when connection is restored
 */
self.addEventListener('sync', event => {
  if (event.tag === BACKGROUND_SYNC_TAG) {
    console.log('Service Worker: Background sync triggered')
    event.waitUntil(syncQueuedInteractions())
  }
})

/**
 * Sync all queued interactions
 */
async function syncQueuedInteractions() {
  try {
    const queuedInteractions = await getOfflineInteractions()
    
    for (const item of queuedInteractions) {
      try {
        const response = await fetch(item.url, {
          method: item.method,
          headers: {
            'Content-Type': 'application/json',
            ...item.headers
          },
          body: JSON.stringify(item.data)
        })
        
        if (response.ok) {
          console.log('Successfully synced interaction:', item.id)
          await removeOfflineInteraction(item.id)
          
          // Notify app of successful sync
          await notifyClientsOfSync(item.id, true)
        } else {
          console.error('Failed to sync interaction:', item.id, response.status)
        }
        
      } catch (error) {
        console.error('Error syncing interaction:', item.id, error)
      }
    }
    
  } catch (error) {
    console.error('Background sync failed:', error)
  }
}

/**
 * IndexedDB operations for offline interaction storage
 */
async function storeOfflineInteraction(item) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('CRMOfflineDB', 1)
    
    request.onerror = () => reject(request.error)
    
    request.onsuccess = () => {
      const db = request.result
      const transaction = db.transaction(['interactions'], 'readwrite')
      const store = transaction.objectStore('interactions')
      
      const addRequest = store.add(item)
      addRequest.onsuccess = () => resolve()
      addRequest.onerror = () => reject(addRequest.error)
    }
    
    request.onupgradeneeded = () => {
      const db = request.result
      if (!db.objectStoreNames.contains('interactions')) {
        const store = db.createObjectStore('interactions', { keyPath: 'id' })
        store.createIndex('timestamp', 'timestamp', { unique: false })
      }
    }
  })
}

async function getOfflineInteractions() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('CRMOfflineDB', 1)
    
    request.onerror = () => reject(request.error)
    
    request.onsuccess = () => {
      const db = request.result
      const transaction = db.transaction(['interactions'], 'readonly')
      const store = transaction.objectStore('interactions')
      
      const getAllRequest = store.getAll()
      getAllRequest.onsuccess = () => resolve(getAllRequest.result)
      getAllRequest.onerror = () => reject(getAllRequest.error)
    }
  })
}

async function removeOfflineInteraction(id) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('CRMOfflineDB', 1)
    
    request.onerror = () => reject(request.error)
    
    request.onsuccess = () => {
      const db = request.result
      const transaction = db.transaction(['interactions'], 'readwrite')
      const store = transaction.objectStore('interactions')
      
      const deleteRequest = store.delete(id)
      deleteRequest.onsuccess = () => resolve()
      deleteRequest.onerror = () => reject(deleteRequest.error)
    }
  })
}

/**
 * Notify app clients of sync results
 */
async function notifyClientsOfSync(interactionId, success) {
  const clients = await self.clients.matchAll()
  
  clients.forEach(client => {
    client.postMessage({
      type: 'INTERACTION_SYNC_RESULT',
      interactionId,
      success,
      timestamp: Date.now()
    })
  })
}

/**
 * Push Notification Support
 */
self.addEventListener('push', event => {
  if (event.data) {
    const data = event.data.json()
    
    const options = {
      body: data.body || 'You have a new notification',
      icon: '/icons/icon-192x192.png',
      badge: '/icons/badge-72x72.png',
      tag: data.tag || 'crm-notification',
      data: data.data || {},
      actions: data.actions || [],
      requireInteraction: data.requireInteraction || false
    }
    
    event.waitUntil(
      self.registration.showNotification(data.title || 'CRM Mobile', options)
    )
  }
})

/**
 * Notification Click Handler
 */
self.addEventListener('notificationclick', event => {
  event.notification.close()
  
  const clickAction = event.action
  const notificationData = event.notification.data
  
  let targetUrl = '/'
  
  if (clickAction === 'view' && notificationData.interactionId) {
    targetUrl = `/interactions/${notificationData.interactionId}`
  } else if (clickAction === 'quick-add') {
    targetUrl = '/interactions/quick'
  }
  
  event.waitUntil(
    self.clients.matchAll({ type: 'window' }).then(clientList => {
      // Focus existing window if available
      for (const client of clientList) {
        if (client.url === new URL(targetUrl, self.location.origin).href && 'focus' in client) {
          return client.focus()
        }
      }
      
      // Open new window
      if (self.clients.openWindow) {
        return self.clients.openWindow(targetUrl)
      }
    })
  )
})

console.log('Service Worker: Loaded and ready for CRM Mobile PWA')