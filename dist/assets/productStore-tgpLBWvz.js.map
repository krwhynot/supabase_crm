{"version":3,"file":"productStore-tgpLBWvz.js","sources":["../../src/services/productsApi.ts","../../src/stores/productStore.ts"],"sourcesContent":["/**\n * Products API Service\n * Centralized Supabase operations for product catalog management\n * Includes principal-product relationship management and filtering\n */\n\nimport { supabase } from '@/config/supabaseClient'\nimport type { \n  Product, \n  ProductInsert, \n  ProductUpdate,\n  ProductWithPrincipals,\n  ProductFilters,\n  ProductStats,\n  ProductPrincipal,\n  ProductOption,\n  BulkProductOperation,\n  BulkProductResult,\n  ProductSearchResult,\n  ProductCategory\n} from '@/types/products'\nimport type { ApiResponse } from './contactsApi'\n\n/**\n * Search and pagination options\n */\nexport interface ProductSearchOptions {\n  search?: string\n  limit?: number\n  offset?: number\n  sortBy?: 'name' | 'category' | 'unit_price' | 'created_at' | 'principal_count'\n  sortOrder?: 'asc' | 'desc'\n  principal_id?: string  // Filter products available to specific principal\n  category?: string\n  is_active?: boolean\n}\n\nclass ProductsApiService {\n\n  /**\n   * Get all products with optional search, filtering, and pagination\n   */\n  async getProducts(options: ProductSearchOptions = {}): Promise<ApiResponse<ProductWithPrincipals[]>> {\n    try {\n      let query = supabase\n        .from('products')\n        .select('*')\n\n      // Apply search filter across multiple fields\n      if (options.search) {\n        query = query.or(`name.ilike.%${options.search}%,description.ilike.%${options.search}%,sku.ilike.%${options.search}%`)\n      }\n\n      // Apply category filter\n      if (options.category) {\n        query = query.eq('category', options.category as ProductCategory)\n      }\n\n      // Apply active status filter\n      if (options.is_active !== undefined) {\n        query = query.eq('is_active', options.is_active)\n      }\n\n      // Apply sorting (skip principal_count for now since we don't have the view)\n      const sortBy = options.sortBy === 'principal_count' ? 'name' : (options.sortBy || 'name')\n      const sortOrder = options.sortOrder || 'asc'\n      query = query.order(sortBy, { ascending: sortOrder === 'asc' })\n\n      // Apply pagination\n      if (options.limit) {\n        query = query.limit(options.limit)\n      }\n      if (options.offset) {\n        query = query.range(options.offset, (options.offset + (options.limit || 50)) - 1)\n      }\n\n      const { data, error } = await query\n\n      if (error) {\n        console.error('Error fetching products:', error)\n        return {\n          data: null,\n          error: `Failed to fetch products: ${error.message}`,\n          success: false\n        }\n      }\n\n      // Transform to ProductWithPrincipals format (simplified for now)\n      const productsWithPrincipals: ProductWithPrincipals[] = (data || []).map(product => ({\n        ...product,\n        is_active: product.is_active ?? true,\n        category: product.category as ProductCategory | null,\n        unit_price: product.suggested_retail_price,\n        principal_ids: [], // TODO: Populate when junction table is implemented\n        principal_names: [],\n        principal_count: 0\n      }))\n\n      return {\n        data: productsWithPrincipals,\n        error: null,\n        success: true\n      }\n    } catch (error) {\n      console.error('Unexpected error fetching products:', error)\n      return {\n        data: null,\n        error: 'An unexpected error occurred while fetching products',\n        success: false\n      }\n    }\n  }\n\n  /**\n   * Get products available to specific principals (for opportunity forms)\n   */\n  async getProductsForPrincipals(principalIds: string[]): Promise<ApiResponse<ProductOption[]>> {\n    try {\n      // For now, return all active products since we don't have the junction table yet\n      const { data, error } = await supabase\n        .from('products')\n        .select('id, name, category, description, suggested_retail_price, is_active')\n        .eq('is_active', true)\n\n      if (error) {\n        console.error('Error fetching products for principals:', error)\n        return {\n          data: null,\n          error: `Failed to fetch products for principals: ${error.message}`,\n          success: false\n        }\n      }\n\n      // Transform to ProductOption format\n      const productOptions: ProductOption[] = (data || []).map(product => ({\n        id: product.id,\n        name: product.name,\n        category: product.category as ProductCategory | null,\n        description: product.description,\n        unit_price: product.suggested_retail_price,\n        is_active: product.is_active ?? true,\n        available_principals: principalIds // Use the input principal IDs for now\n      }))\n\n      return {\n        data: productOptions,\n        error: null,\n        success: true\n      }\n    } catch (error) {\n      console.error('Unexpected error fetching products for principals:', error)\n      return {\n        data: null,\n        error: 'An unexpected error occurred while fetching products for principals',\n        success: false\n      }\n    }\n  }\n\n  /**\n   * Get a single product by ID\n   */\n  async getProduct(id: string): Promise<ApiResponse<Product>> {\n    try {\n      const { data, error } = await supabase\n        .from('products')\n        .select('*')\n        .eq('id', id)\n        .single()\n\n      if (error) {\n        console.error('Error fetching product:', error)\n        return {\n          data: null,\n          error: `Failed to fetch product: ${error.message}`,\n          success: false\n        }\n      }\n\n      return {\n        data: {\n          ...data,\n          category: data.category as ProductCategory | null,\n          unit_price: data.suggested_retail_price,\n          created_by: null\n        } as Product,\n        error: null,\n        success: true\n      }\n    } catch (error) {\n      console.error('Unexpected error fetching product:', error)\n      return {\n        data: null,\n        error: 'An unexpected error occurred while fetching the product',\n        success: false\n      }\n    }\n  }\n\n  /**\n   * Create a new product\n   */\n  async createProduct(product: ProductInsert): Promise<ApiResponse<Product>> {\n    try {\n      const { data, error } = await supabase\n        .from('products')\n        .insert(product)\n        .select()\n        .single()\n\n      if (error) {\n        console.error('Error creating product:', error)\n        return {\n          data: null,\n          error: `Failed to create product: ${error.message}`,\n          success: false\n        }\n      }\n\n      return {\n        data: {\n          ...data,\n          category: data.category as ProductCategory | null,\n          unit_price: data.suggested_retail_price,\n          created_by: null\n        } as Product,\n        error: null,\n        success: true\n      }\n    } catch (error) {\n      console.error('Unexpected error creating product:', error)\n      return {\n        data: null,\n        error: 'An unexpected error occurred while creating the product',\n        success: false\n      }\n    }\n  }\n\n  /**\n   * Update an existing product\n   */\n  async updateProduct(id: string, updates: ProductUpdate): Promise<ApiResponse<Product>> {\n    try {\n      const { data, error } = await supabase\n        .from('products')\n        .update(updates)\n        .eq('id', id)\n        .select()\n        .single()\n\n      if (error) {\n        console.error('Error updating product:', error)\n        return {\n          data: null,\n          error: `Failed to update product: ${error.message}`,\n          success: false\n        }\n      }\n\n      return {\n        data: {\n          ...data,\n          category: data.category as ProductCategory | null,\n          unit_price: data.suggested_retail_price,\n          created_by: null\n        } as Product,\n        error: null,\n        success: true\n      }\n    } catch (error) {\n      console.error('Unexpected error updating product:', error)\n      return {\n        data: null,\n        error: 'An unexpected error occurred while updating the product',\n        success: false\n      }\n    }\n  }\n\n  /**\n   * Delete a product (soft delete)\n   */\n  async deleteProduct(id: string): Promise<ApiResponse<boolean>> {\n    try {\n      const { error } = await supabase\n        .from('products')\n        .update({ \n          is_active: false,\n          deleted_at: new Date().toISOString()\n        })\n        .eq('id', id)\n\n      if (error) {\n        console.error('Error deleting product:', error)\n        return {\n          data: null,\n          error: `Failed to delete product: ${error.message}`,\n          success: false\n        }\n      }\n\n      return {\n        data: true,\n        error: null,\n        success: true\n      }\n    } catch (error) {\n      console.error('Unexpected error deleting product:', error)\n      return {\n        data: null,\n        error: 'An unexpected error occurred while deleting the product',\n        success: false\n      }\n    }\n  }\n\n  /**\n   * Assign product to principals\n   */\n  async assignProductToPrincipals(productId: string, principalIds: string[]): Promise<ApiResponse<ProductPrincipal[]>> {\n    try {\n      // First, remove existing assignments\n      await supabase\n        .from('product_principals')\n        .delete()\n        .eq('product_id', productId)\n\n      // Then, create new assignments\n      const assignments = principalIds.map(principalId => ({\n        product_id: productId,\n        principal_id: principalId\n      }))\n\n      const { data, error } = await supabase\n        .from('product_principals')\n        .insert(assignments)\n        .select(`\n          *,\n          products!inner(name, category),\n          organizations!inner(name, type)\n        `)\n\n      if (error) {\n        console.error('Error assigning product to principals:', error)\n        return {\n          data: null,\n          error: `Failed to assign product to principals: ${error.message}`,\n          success: false\n        }\n      }\n\n      // Transform the response to match ProductPrincipal interface\n      const productPrincipals: ProductPrincipal[] = (data || []).map(item => ({\n        id: item.id,\n        product_id: item.product_id,\n        principal_id: item.principal_id,\n        created_at: item.created_at || new Date().toISOString(),\n        product_name: (item as any).products?.name || '',\n        product_category: (item as any).products?.category as ProductCategory | null,\n        principal_name: (item as any).organizations?.name || '',\n        principal_type: (item as any).organizations?.type || ''\n      }))\n\n      return {\n        data: productPrincipals,\n        error: null,\n        success: true\n      }\n    } catch (error) {\n      console.error('Unexpected error assigning product to principals:', error)\n      return {\n        data: null,\n        error: 'An unexpected error occurred while assigning product to principals',\n        success: false\n      }\n    }\n  }\n\n  /**\n   * Get product statistics\n   */\n  async getProductStats(): Promise<ApiResponse<ProductStats>> {\n    try {\n      // Get total and active product counts\n      const [totalResult, activeResult] = await Promise.all([\n        supabase.from('products').select('*', { count: 'exact', head: true }),\n        supabase.from('products').select('*', { count: 'exact', head: true }).eq('is_active', true)\n      ])\n\n      if (totalResult.error) throw totalResult.error\n      if (activeResult.error) throw activeResult.error\n\n      const total = totalResult.count || 0\n      const active = activeResult.count || 0\n\n      // Get products by category\n      const { data: categoryData, error: categoryError } = await supabase\n        .from('products')\n        .select('category')\n        .eq('is_active', true)\n\n      if (categoryError) throw categoryError\n\n      // Count by category\n      const categoryCount = (categoryData || []).reduce((acc, item) => {\n        const category = item.category as ProductCategory | null\n        if (category) {\n          acc[category] = (acc[category] || 0) + 1\n        }\n        return acc\n      }, {} as { [K in ProductCategory]: number })\n\n      // Get price statistics\n      const { data: priceData, error: priceError } = await supabase\n        .from('products')\n        .select('suggested_retail_price')\n        .eq('is_active', true)\n        .not('suggested_retail_price', 'is', null)\n\n      if (priceError) throw priceError\n\n      const prices = (priceData || []).map(item => item.suggested_retail_price).filter(price => price !== null)\n      const averagePrice = prices.length > 0 ? prices.reduce((sum, price) => sum + price, 0) / prices.length : 0\n      const minPrice = prices.length > 0 ? Math.min(...prices) : 0\n      const maxPrice = prices.length > 0 ? Math.max(...prices) : 0\n\n      // Get most common category\n      const mostCommonCategory = Object.entries(categoryCount)\n        .sort(([,a], [,b]) => (b as number) - (a as number))[0]?.[0] as ProductCategory\n\n      // Get recently added count (last 30 days)\n      const thirtyDaysAgo = new Date()\n      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)\n      \n      const { count: recentlyAdded, error: recentError } = await supabase\n        .from('products')\n        .select('*', { count: 'exact', head: true })\n        .gte('created_at', thirtyDaysAgo.toISOString())\n\n      if (recentError) throw recentError\n\n      const stats: ProductStats = {\n        total_products: total,\n        active_products: active,\n        inactive_products: total - active,\n        products_by_category: categoryCount,\n        average_price: averagePrice,\n        price_range: {\n          min: minPrice,\n          max: maxPrice\n        },\n        most_common_category: mostCommonCategory,\n        recently_added: recentlyAdded || 0\n      }\n\n      return {\n        data: stats,\n        error: null,\n        success: true\n      }\n    } catch (error) {\n      console.error('Error fetching product stats:', error)\n      return {\n        data: null,\n        error: 'Failed to fetch product statistics',\n        success: false\n      }\n    }\n  }\n\n  /**\n   * Search products with advanced matching\n   */\n  async searchProducts(\n    searchTerm: string, \n    filters: ProductFilters = {}\n  ): Promise<ApiResponse<ProductSearchResult[]>> {\n    try {\n      let query = supabase\n        .from('products')\n        .select('*')\n\n      // Apply basic filters\n      if (filters.category && filters.category.length > 0) {\n        query = query.in('category', filters.category as ProductCategory[])\n      }\n\n      if (filters.is_active !== undefined) {\n        query = query.eq('is_active', filters.is_active)\n      }\n\n      // TODO: Implement principal filtering when junction table is available\n\n      // Apply price range filters\n      if (filters.price_min !== undefined) {\n        query = query.gte('suggested_retail_price', filters.price_min)\n      }\n\n      if (filters.price_max !== undefined) {\n        query = query.lte('suggested_retail_price', filters.price_max)\n      }\n\n      // Apply search term\n      if (searchTerm.trim()) {\n        query = query.or(`name.ilike.%${searchTerm}%,description.ilike.%${searchTerm}%,sku.ilike.%${searchTerm}%`)\n      }\n\n      const { data, error } = await query\n\n      if (error) {\n        console.error('Error searching products:', error)\n        return {\n          data: null,\n          error: `Failed to search products: ${error.message}`,\n          success: false\n        }\n      }\n\n      // Transform results and calculate match scores\n      const results: ProductSearchResult[] = (data || []).map(product => {\n        const matchScore = this.calculateMatchScore(product, searchTerm)\n        const highlightFields = this.getHighlightFields(product, searchTerm)\n\n        return {\n          id: String(product.id),\n          name: product.name,\n          category: product.category as ProductCategory | null,\n          description: product.description,\n          unit_price: product.suggested_retail_price,\n          match_score: matchScore,\n          available_for_principals: [], // TODO: Populate when junction table is implemented\n          highlight_fields: highlightFields\n        }\n      })\n\n      // Sort by match score\n      results.sort((a, b) => b.match_score - a.match_score)\n\n      return {\n        data: results,\n        error: null,\n        success: true\n      }\n    } catch (error) {\n      console.error('Unexpected error searching products:', error)\n      return {\n        data: null,\n        error: 'An unexpected error occurred while searching products',\n        success: false\n      }\n    }\n  }\n\n  /**\n   * Perform bulk operations on products\n   */\n  async performBulkOperation(operation: BulkProductOperation): Promise<ApiResponse<BulkProductResult>> {\n    try {\n      const results: BulkProductResult = {\n        success: true,\n        processed_count: 0,\n        failed_count: 0,\n        errors: [],\n        updated_products: []\n      }\n\n      for (const productId of operation.product_ids) {\n        try {\n          let updateData: any = {}\n\n          switch (operation.operation) {\n            case 'activate':\n              updateData = { is_active: true }\n              break\n            case 'deactivate':\n              updateData = { is_active: false }\n              break\n            case 'delete':\n              updateData = { \n                is_active: false, \n                deleted_at: new Date().toISOString() \n              }\n              break\n            case 'update_category':\n              if (operation.parameters?.category) {\n                updateData = { category: operation.parameters.category }\n              }\n              break\n            default:\n              throw new Error(`Unsupported operation: ${operation.operation}`)\n          }\n\n          const { data, error } = await supabase\n            .from('products')\n            .update(updateData)\n            .eq('id', productId)\n            .select()\n            .single()\n\n          if (error) throw error\n\n          results.updated_products.push({\n            ...data,\n            category: data.category as ProductCategory | null,\n            unit_price: data.suggested_retail_price,\n            created_by: null\n          } as Product)\n          results.processed_count++\n\n        } catch (error: any) {\n          // Get product name for error reporting\n          const { data: product } = await supabase\n            .from('products')\n            .select('name')\n            .eq('id', productId)\n            .single()\n\n          results.errors.push({\n            product_id: productId,\n            product_name: product?.name || 'Unknown Product',\n            error_message: error.message || 'Unknown error'\n          })\n          results.failed_count++\n        }\n      }\n\n      results.success = results.failed_count === 0\n\n      return {\n        data: results,\n        error: null,\n        success: true\n      }\n    } catch (error) {\n      console.error('Unexpected error performing bulk operation:', error)\n      return {\n        data: null,\n        error: 'An unexpected error occurred during bulk operation',\n        success: false\n      }\n    }\n  }\n\n  /**\n   * Calculate search match score for ranking\n   */\n  private calculateMatchScore(product: any, searchTerm: string): number {\n    if (!searchTerm.trim()) return 1\n\n    const term = searchTerm.toLowerCase()\n    let score = 0\n\n    // Exact name match gets highest score\n    if (product.name.toLowerCase() === term) {\n      score += 100\n    } else if (product.name.toLowerCase().includes(term)) {\n      score += 50\n    }\n\n    // SKU match gets high score\n    if (product.sku && product.sku.toLowerCase().includes(term)) {\n      score += 30\n    }\n\n    // Description match gets lower score\n    if (product.description && product.description.toLowerCase().includes(term)) {\n      score += 10\n    }\n\n    // Category match gets minimal score\n    if (product.category.toLowerCase().includes(term)) {\n      score += 5\n    }\n\n    return score\n  }\n\n  /**\n   * Get fields that matched the search term for highlighting\n   */\n  private getHighlightFields(product: any, searchTerm: string): string[] {\n    if (!searchTerm.trim()) return []\n\n    const term = searchTerm.toLowerCase()\n    const fields: string[] = []\n\n    if (product.name.toLowerCase().includes(term)) {\n      fields.push('name')\n    }\n\n    if (product.sku && product.sku.toLowerCase().includes(term)) {\n      fields.push('sku')\n    }\n\n    if (product.description && product.description.toLowerCase().includes(term)) {\n      fields.push('description')\n    }\n\n    if (product.category.toLowerCase().includes(term)) {\n      fields.push('category')\n    }\n\n    return fields\n  }\n\n}\n\n// Export singleton instance\nexport const productsApi = new ProductsApiService()\n\n// Export class for testing\nexport { ProductsApiService }","/**\n * Product Store - Comprehensive State Management\n * Manages product catalog, principal-product relationships, and product analytics\n * Optimized for opportunity form integration and product filtering\n */\n\nimport { defineStore } from 'pinia'\nimport { ref, computed, reactive } from 'vue'\nimport { productsApi } from '@/services/productsApi'\nimport type {\n  Product,\n  ProductWithPrincipals,\n  ProductOption,\n  ProductFilters,\n  ProductStats,\n  ProductSearchResult,\n  BulkProductOperation,\n  BulkProductResult,\n  ProductCategory\n} from '@/types/products'\n// ApiResponse type from productsApi - used for consistent API responses\n\n/**\n * Store state interface for better type safety\n */\ninterface ProductStoreState {\n  // Data collections\n  products: ProductWithPrincipals[]\n  selectedProduct: Product | null\n  productOptions: ProductOption[] // For opportunity forms\n  \n  // UI state\n  loading: boolean\n  creating: boolean\n  updating: boolean\n  deleting: boolean\n  \n  // Error handling\n  error: string | null\n  \n  // Search and filtering\n  searchResults: ProductSearchResult[]\n  searchTerm: string\n  \n  // Analytics\n  stats: ProductStats | null\n  \n  // Bulk operations\n  bulkOperationResult: BulkProductResult | null\n}\n\nexport const useProductStore = defineStore('product', () => {\n  // ===============================\n  // STATE MANAGEMENT\n  // ===============================\n  \n  const state = reactive<ProductStoreState>({\n    // Data collections\n    products: [],\n    selectedProduct: null,\n    productOptions: [],\n    \n    // UI state\n    loading: false,\n    creating: false,\n    updating: false,\n    deleting: false,\n    \n    // Error handling\n    error: null,\n    \n    // Search and filtering\n    searchResults: [],\n    searchTerm: '',\n    \n    // Analytics\n    stats: null,\n    \n    // Bulk operations\n    bulkOperationResult: null\n  })\n\n  // Active filters for product list\n  const activeFilters = ref<ProductFilters>({})\n\n  // ===============================\n  // COMPUTED PROPERTIES\n  // ===============================\n  \n  const isLoading = computed(() => \n    state.loading || state.creating || state.updating || state.deleting\n  )\n  \n  const hasError = computed(() => !!state.error)\n  \n  const productCount = computed(() => state.products.length)\n  \n  const activeProductCount = computed(() => \n    state.products.filter(p => p.is_active).length\n  )\n  \n  const getProductById = computed(() => {\n    return (id: string) => state.products.find(p => p.id === id)\n  })\n  \n  const getProductsByCategory = computed(() => {\n    return (category: ProductCategory) => \n      state.products.filter(p => p.category === category)\n  })\n  \n  const getProductsForPrincipals = computed(() => {\n    return (principalIds: string[]) => \n      state.productOptions.filter(p => \n        p.available_principals.some(pid => principalIds.includes(pid))\n      )\n  })\n  \n  const categoriesInUse = computed(() => {\n    const categories = new Set<ProductCategory>()\n    state.products.forEach(product => {\n      if (product.category) {\n        categories.add(product.category)\n      }\n    })\n    return Array.from(categories)\n  })\n\n  // ===============================\n  // ACTIONS - CRUD OPERATIONS\n  // ===============================\n  \n  /**\n   * Fetch products with optional search and filtering\n   */\n  const fetchProducts = async (options: any = {}): Promise<void> => {\n    state.loading = true\n    state.error = null\n    \n    try {\n      const response = await productsApi.getProducts(options)\n      \n      if (response.success && response.data) {\n        state.products = response.data\n      } else {\n        state.error = response.error || 'Failed to fetch products'\n      }\n    } catch (error) {\n      state.error = error instanceof Error ? error.message : 'Unexpected error occurred'\n    } finally {\n      state.loading = false\n    }\n  }\n  \n  /**\n   * Fetch products available to specific principals (for opportunity forms)\n   */\n  const fetchProductsForPrincipals = async (principalIds: string[]): Promise<void> => {\n    state.loading = true\n    state.error = null\n    \n    try {\n      const response = await productsApi.getProductsForPrincipals(principalIds)\n      \n      if (response.success && response.data) {\n        state.productOptions = response.data\n      } else {\n        state.error = response.error || 'Failed to fetch products for principals'\n      }\n    } catch (error) {\n      state.error = error instanceof Error ? error.message : 'Unexpected error occurred'\n    } finally {\n      state.loading = false\n    }\n  }\n  \n  /**\n   * Fetch a single product by ID\n   */\n  const fetchProductById = async (id: string): Promise<void> => {\n    state.loading = true\n    state.error = null\n    \n    try {\n      const response = await productsApi.getProduct(id)\n      \n      if (response.success && response.data) {\n        state.selectedProduct = response.data\n      } else {\n        state.error = response.error || 'Failed to fetch product'\n      }\n    } catch (error) {\n      state.error = error instanceof Error ? error.message : 'Unexpected error occurred'\n    } finally {\n      state.loading = false\n    }\n  }\n  \n  /**\n   * Create a new product\n   */\n  const createProduct = async (productData: any): Promise<boolean> => {\n    state.creating = true\n    state.error = null\n    \n    try {\n      const response = await productsApi.createProduct(productData)\n      \n      if (response.success && response.data) {\n        // Add to local state\n        const newProductWithPrincipals: ProductWithPrincipals = {\n          ...response.data,\n          principal_ids: [],\n          principal_names: [],\n          principal_count: 0\n        }\n        state.products.unshift(newProductWithPrincipals)\n        \n        return true\n      } else {\n        state.error = response.error || 'Failed to create product'\n        return false\n      }\n    } catch (error) {\n      state.error = error instanceof Error ? error.message : 'Unexpected error occurred'\n      return false\n    } finally {\n      state.creating = false\n    }\n  }\n  \n  /**\n   * Update an existing product\n   */\n  const updateProduct = async (id: string, updates: any): Promise<boolean> => {\n    state.updating = true\n    state.error = null\n    \n    try {\n      const response = await productsApi.updateProduct(id, updates)\n      \n      if (response.success && response.data) {\n        // Update in local state\n        const index = state.products.findIndex(p => p.id === id)\n        if (index !== -1) {\n          state.products[index] = {\n            ...state.products[index],\n            ...response.data\n          }\n        }\n        \n        // Update selected product if it's the same one\n        if (state.selectedProduct?.id === id) {\n          state.selectedProduct = response.data\n        }\n        \n        return true\n      } else {\n        state.error = response.error || 'Failed to update product'\n        return false\n      }\n    } catch (error) {\n      state.error = error instanceof Error ? error.message : 'Unexpected error occurred'\n      return false\n    } finally {\n      state.updating = false\n    }\n  }\n  \n  /**\n   * Delete a product (soft delete)\n   */\n  const deleteProduct = async (id: string): Promise<boolean> => {\n    state.deleting = true\n    state.error = null\n    \n    try {\n      const response = await productsApi.deleteProduct(id)\n      \n      if (response.success) {\n        // Update in local state (soft delete - mark as inactive)\n        const index = state.products.findIndex(p => p.id === id)\n        if (index !== -1) {\n          state.products[index].is_active = false\n        }\n        \n        // Clear selected product if it was deleted\n        if (state.selectedProduct?.id === id) {\n          state.selectedProduct = null\n        }\n        \n        return true\n      } else {\n        state.error = response.error || 'Failed to delete product'\n        return false\n      }\n    } catch (error) {\n      state.error = error instanceof Error ? error.message : 'Unexpected error occurred'\n      return false\n    } finally {\n      state.deleting = false\n    }\n  }\n  \n  /**\n   * Assign product to principals\n   */\n  const assignProductToPrincipals = async (productId: string, principalIds: string[]): Promise<boolean> => {\n    state.updating = true\n    state.error = null\n    \n    try {\n      const response = await productsApi.assignProductToPrincipals(productId, principalIds)\n      \n      if (response.success && response.data) {\n        // Update local state with new principal assignments\n        const index = state.products.findIndex(p => p.id === productId)\n        if (index !== -1) {\n          state.products[index].principal_ids = principalIds\n          state.products[index].principal_count = principalIds.length\n          // Principal names would need to be fetched separately\n        }\n        \n        return true\n      } else {\n        state.error = response.error || 'Failed to assign product to principals'\n        return false\n      }\n    } catch (error) {\n      state.error = error instanceof Error ? error.message : 'Unexpected error occurred'\n      return false\n    } finally {\n      state.updating = false\n    }\n  }\n\n  // ===============================\n  // ACTIONS - SEARCH & ANALYTICS\n  // ===============================\n  \n  /**\n   * Search products with advanced matching\n   */\n  const searchProducts = async (searchTerm: string, filters: ProductFilters = {}): Promise<void> => {\n    state.loading = true\n    state.error = null\n    state.searchTerm = searchTerm\n    \n    try {\n      const response = await productsApi.searchProducts(searchTerm, filters)\n      \n      if (response.success && response.data) {\n        state.searchResults = response.data\n      } else {\n        state.error = response.error || 'Failed to search products'\n      }\n    } catch (error) {\n      state.error = error instanceof Error ? error.message : 'Unexpected error occurred'\n    } finally {\n      state.loading = false\n    }\n  }\n  \n  /**\n   * Fetch product statistics for dashboard\n   */\n  const fetchStats = async (): Promise<void> => {\n    state.loading = true\n    state.error = null\n    \n    try {\n      const response = await productsApi.getProductStats()\n      \n      if (response.success && response.data) {\n        state.stats = response.data\n      } else {\n        state.error = response.error || 'Failed to fetch product statistics'\n      }\n    } catch (error) {\n      state.error = error instanceof Error ? error.message : 'Unexpected error occurred'\n    } finally {\n      state.loading = false\n    }\n  }\n  \n  /**\n   * Perform bulk operations on products\n   */\n  const performBulkOperation = async (operation: BulkProductOperation): Promise<boolean> => {\n    state.updating = true\n    state.error = null\n    state.bulkOperationResult = null\n    \n    try {\n      const response = await productsApi.performBulkOperation(operation)\n      \n      if (response.success && response.data) {\n        state.bulkOperationResult = response.data\n        \n        // Update local state based on operation\n        if (response.data.success) {\n          operation.product_ids.forEach(productId => {\n            const index = state.products.findIndex(p => p.id === productId)\n            if (index !== -1) {\n              switch (operation.operation) {\n                case 'activate':\n                  state.products[index].is_active = true\n                  break\n                case 'deactivate':\n                case 'delete':\n                  state.products[index].is_active = false\n                  break\n                case 'update_category':\n                  if (operation.parameters?.category) {\n                    state.products[index].category = operation.parameters.category\n                  }\n                  break\n              }\n            }\n          })\n        }\n        \n        return response.data.success\n      } else {\n        state.error = response.error || 'Failed to perform bulk operation'\n        return false\n      }\n    } catch (error) {\n      state.error = error instanceof Error ? error.message : 'Unexpected error occurred'\n      return false\n    } finally {\n      state.updating = false\n    }\n  }\n\n  // ===============================\n  // ACTIONS - UTILITY FUNCTIONS\n  // ===============================\n  \n  /**\n   * Clear all error states\n   */\n  const clearError = (): void => {\n    state.error = null\n  }\n  \n  /**\n   * Clear selected product\n   */\n  const clearSelectedProduct = (): void => {\n    state.selectedProduct = null\n  }\n  \n  /**\n   * Clear search results\n   */\n  const clearSearchResults = (): void => {\n    state.searchResults = []\n    state.searchTerm = ''\n  }\n  \n  /**\n   * Clear bulk operation results\n   */\n  const clearBulkResults = (): void => {\n    state.bulkOperationResult = null\n  }\n  \n  /**\n   * Reset filters to defaults\n   */\n  const resetFilters = (): void => {\n    activeFilters.value = {}\n  }\n  \n  /**\n   * Refresh current data\n   */\n  const refresh = async (): Promise<void> => {\n    await fetchProducts()\n  }\n\n  // ===============================\n  // RETURN STORE INTERFACE\n  // ===============================\n  \n  return {\n    // State\n    ...state,\n    activeFilters,\n    \n    // Computed\n    isLoading,\n    hasError,\n    productCount,\n    activeProductCount,\n    getProductById,\n    getProductsByCategory,\n    getProductsForPrincipals,\n    categoriesInUse,\n    \n    // Actions - CRUD\n    fetchProducts,\n    fetchProductsForPrincipals,\n    fetchProductById,\n    createProduct,\n    updateProduct,\n    deleteProduct,\n    assignProductToPrincipals,\n    \n    // Actions - Search & Analytics\n    searchProducts,\n    fetchStats,\n    performBulkOperation,\n    \n    // Actions - Utilities\n    clearError,\n    clearSelectedProduct,\n    clearSearchResults,\n    clearBulkResults,\n    resetFilters,\n    refresh\n  }\n})"],"names":["ProductsApiService","options","query","supabase","sortBy","sortOrder","data","error","product","principalIds","id","updates","productId","assignments","principalId","item","_a","_b","_c","_d","totalResult","activeResult","total","active","categoryData","categoryError","categoryCount","acc","category","priceData","priceError","prices","price","averagePrice","sum","minPrice","maxPrice","mostCommonCategory","a","b","thirtyDaysAgo","recentlyAdded","recentError","searchTerm","filters","results","matchScore","highlightFields","operation","updateData","term","score","fields","productsApi","useProductStore","defineStore","state","reactive","activeFilters","ref","isLoading","computed","hasError","productCount","activeProductCount","p","getProductById","getProductsByCategory","getProductsForPrincipals","pid","categoriesInUse","categories","fetchProducts","response","productData","newProductWithPrincipals","index"],"mappings":"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"}